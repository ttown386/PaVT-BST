\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{graphicx, float}
\usepackage{mathtools}
\usepackage{listings}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage{xcolor}
\usepackage{listings}

\definecolor{mGreen}{rgb}{0,0.6,0}
\definecolor{mGray}{rgb}{0.5,0.5,0.5}
\definecolor{mPurple}{rgb}{0.58,0,0.82}
\definecolor{backgroundColour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{CStyle}{
    backgroundcolor=\color{backgroundColour},   
    commentstyle=\color{mGreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{mGray},
    stringstyle=\color{mPurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=C
}


\author{Robert Bland and Tyler Townsend}

\title{Homework Assignment 2}

\begin{document}

\maketitle

\section{Tower Probe Race condition: CVE-2017-15102} 

\subsection{Problem}
The\texttt{ tower\_probe} function has a security vulnerability. This is vulnerability is exposed when a write operation happens concurrently with a \texttt{tower\_delete}, which is called and derefences a pointer that will be used later with the write operation. This scenario is a race condition and has to be set up in a distinct series of operations discussed in the next subsection.  One requirement is to delay the control message sent in the probe function in \texttt{legousbtower.c}. This is done between the registering of the interface and the reading of the boards firmware ID. Another requirement for this vulnerability is that the 0 address must be mappable on the machine. This allows it to be possible to create a local privilege escalation exploit using a write-what-where condition. This exploit is caused by a remapping of the dev-interrupt\_out\_buffer in \texttt{tower\_write} operation that was called via a\texttt{ NULL} dereference. This means that is now possible to run any malicious scripts from that USB on the computer. 

\subsection{Existence}
This vulnerability has existed since 2003 and just recently got patched in March 2018, although this did have solutions readily available last year with a simple change in structure[3]. The versions it ranges from version 2.6.12.1 up to 4.8.11 and exists on Redhat Enterprise Linux version 5 \& version 6[1]. The severity of this problem was listed as a 6.9 since the requirements to do it needed the person to physically plug it in, but if they managed to do this then they could run any script using that USB\cite{NVD}.

\subsection{Exact Location and Execution of Problem}
One thing to note before we start assumptions is that not all of the code for \texttt{tower\_probe} is shown below, but it's enough to show the problem at hand. Now we will assume that we have tampered the USB's firmware ID to throw an error later and that we will run a write operation concurrently later as well. We execute \texttt{tower\_probe} until we finish registering our USB device on line 22. Then we delay the thread that is running the probe function before it reaches line 25. Then the write operation mentioned earlier will initiate a write to the device file. We stop stalling \texttt{tower\_probe} and line 25 will throw an error because of the ID and call Tower\_delete. This does not stop the execution of this write operation and tower\_delete will free \texttt{dev->interrupt\_out\_urb} on line 7. Now the write operation will throw a\texttt{ NULL} derefence at line 6 and 18 and will remap \texttt{dev->interrupt\_out\_urb} to 0. This now is a write-what-where condition and creates a local privilege escalation exploit which then allows us to run any malicious code.
\begin{lstlisting}[style=CStyle]
@@ -886,24 +886,6 @@ static int tower_probe (struct usb_interface *interface, const struct usb_device
...
 	dev->interrupt_in_interval = interrupt_in_interval ? interrupt_in_interval : dev->interrupt_in_endpoint->bInterval;
 	dev->interrupt_out_interval = interrupt_out_interval ? interrupt_out_interval : dev->interrupt_out_endpoint->bInterval;
 
	/* we can register the device now, as it is ready */
	usb_set_intfdata (interface, dev);

	retval = usb_register_dev (interface, &tower_class);

	if (retval) {
		/* something prevented us from registering this driver */
		dev_err(idev, "Not able to get a minor for this device.\n");
		usb_set_intfdata (interface, NULL);
		goto error;
	}
	dev->minor = interface->minor;

	/* let the user know what node this device is now attached to */
	dev_info(&interface->dev, "LEGO USB Tower #%d now attached to major "
		 "%d minor %d\n", (dev->minor - LEGO_USB_TOWER_MINOR_BASE),
		 USB_MAJOR, dev->minor);

 	/* get the firmware version and log it */
 	result = usb_control_msg (udev,
 				  usb_rcvctrlpipe(udev, 0),
@@ -924,6 +906,23 @@ static int tower_probe (struct usb_interface *interface, const struct usb_device
 		 get_version_reply.minor,
 		 le16_to_cpu(get_version_reply.build_no));
 
 exit:
 	return retval;
\end{lstlisting}
\centerline{\textbf{Figure 1.1: \texttt{tower\_probe()}}}
\vspace{12pt}

\begin{lstlisting}[style=CStyle]
static inline void tower_delete (struct lego_usb_tower *dev)
{
	tower_abort_transfers (dev);

	/* free data structures */
	usb_free_urb(dev->interrupt_in_urb);
	usb_free_urb(dev->interrupt_out_urb);
	kfree (dev->read_buffer);
	kfree (dev->interrupt_in_buffer);
	kfree (dev->interrupt_out_buffer);
	kfree (dev);
}
\end{lstlisting}
\centerline{\textbf{Figure 1.2: \texttt{tower\_delete()}}}
\vspace{12pt}

\begin{lstlisting}[style=CStyle]
static ssize_t tower_write	(struct file *file, const char __user *buffer, size_t count, loff_t *ppos)
{
	...
	
	/* send off the urb */
	usb_fill_int_urb(dev->interrupt_out_urb,
			 dev->udev,
			 usb_sndintpipe(dev->udev, dev->interrupt_out_endpoint->bEndpointAddress),
			 dev->interrupt_out_buffer,
			 bytes_to_write,
			 tower_interrupt_out_callback,
			 dev,
			 dev->interrupt_out_interval);

	dev->interrupt_out_busy = 1;
	wmb();

	retval = usb_submit_urb (dev->interrupt_out_urb, GFP_KERNEL);
	if (retval) {
		dev->interrupt_out_busy = 0;
		dev_err(&dev->udev->dev,
			"Couldn't submit interrupt_out_urb %d\n", retval);
		goto unlock_exit;
	}	
	
	...
	unlock_exit:
	/* unlock the device */
	mutex_unlock(&dev->lock);

exit:
	return retval;
}
}
\end{lstlisting}
\centerline{\textbf{Figure 1.3: \texttt{tower\_write()}}}
\vspace{12pt}

\subsection{Solution}
The solution is surprisingly simple since it only requires us to change where we register the USB interface[3]. Normally the program registers the USB interface then checks the firmware ID, but in the solution we move the code for registering the USB after we check the firmware ID. This makes it impossible for a user to use the USB and do a write operation before confirming the ID, thus eliminating the race-condition. As shown in the code below, the lines with the negative symbols are the lines we delete and the lines with the plus symbols are the ones where we add to the code and it is a simple cut and paste. The $+$ indicate added lines and the $-$ indicate removed lines.
\begin{lstlisting}[style=CStyle]
@@ -886,24 +886,6 @@ static int tower_probe (struct usb_interface *interface, const struct usb_device
...
 	dev->interrupt_in_interval = interrupt_in_interval ? interrupt_in_interval : dev->interrupt_in_endpoint->bInterval;
 	dev->interrupt_out_interval = interrupt_out_interval ? interrupt_out_interval : dev->interrupt_out_endpoint->bInterval;
 
-	/* we can register the device now, as it is ready */
-	usb_set_intfdata (interface, dev);
-
-	retval = usb_register_dev (interface, &tower_class);
-
-	if (retval) {
-		/* something prevented us from registering this driver */
-		dev_err(idev, "Not able to get a minor for this device.\n");
-		usb_set_intfdata (interface, NULL);
-		goto error;
-	}
-	dev->minor = interface->minor;
-
-	/* let the user know what node this device is now attached to */
-	dev_info(&interface->dev, "LEGO USB Tower #%d now attached to major "
-		 "%d minor %d\n", (dev->minor - LEGO_USB_TOWER_MINOR_BASE),
-		 USB_MAJOR, dev->minor);
-
 	/* get the firmware version and log it */
 	result = usb_control_msg (udev,
 				  usb_rcvctrlpipe(udev, 0),
@@ -924,6 +906,23 @@ static int tower_probe (struct usb_interface *interface, const struct usb_device
 		 get_version_reply.minor,
 		 le16_to_cpu(get_version_reply.build_no));
 
+	/* we can register the device now, as it is ready */
+	usb_set_intfdata (interface, dev);
+
+	retval = usb_register_dev (interface, &tower_class);
+
+	if (retval) {
+		/* something prevented us from registering this driver */
+		dev_err(idev, "Not able to get a minor for this device.\n");
+		usb_set_intfdata (interface, NULL);
+		goto error;
+	}
+	dev->minor = interface->minor;
+
+	/* let the user know what node this device is now attached to */
+	dev_info(&interface->dev, "LEGO USB Tower #%d now attached to major "
+		 "%d minor %d\n", (dev->minor - LEGO_USB_TOWER_MINOR_BASE),
+		 USB_MAJOR, dev->minor);
 
 exit:
 	return retval;
\end{lstlisting}
\centerline{\textbf{Figure 1.4: Solution to \texttt{tower\_probe()}}}
\vspace{12pt}

\subsection{Concurrency}
This is related to concurrency since this problem only exists since we can do a read/write operation while the program is registering the USB and checking the board firmware ID. If this was executed in a sequential manner then delaying the probe function would be pointless since it will not be able to execute anything else until this delay is done. Which will eventually throw an error and cause the queued write operation to never happen since the device will be unregistered before it can write. This portrays just how serious race conditions are in a concurrent environment and how small changes or certain conditions can allow attackers to run malicious code. These conditions are very spread out and hard to find, but can exist for over a decade before it even gets patched out. This is pretty terrifying knowing that concurrent programs can have unexpected outcomes that lead to more than just mismatched data and incorrect sequential outcomes, since this outcome let the attacker do anything they want. Preventive measures for this scenario would have been to reconsider the ordering of registering a device and checking it's firmware. Clearly if we have an operation that can nullify the work done in the previous lines of code, then it would be more optimal to check that scenario first then to continue with the rest of the program.

\newpage
\section{Driver\_override: CVE-2017-12146}
\subsection{Problem Description}
The vulnerability of the \texttt{driver\_override} implementation in drivers/base/platform.c in the Linux kernel (before 4.12.1) is susceptible to race condition when different threads are reading vs storing a different driver override \cite{bugzilla}. The race condition allows local users to gain elevated privileges by leveraging the race condition. A local attacker could use this to possibly gain administrative privileges\cite{ubuntu-security}.

\subsection{History}
The weakness was released 09/08/2017 and traded as CVE-2017-12146 since 08/01/2017. The attack needs to be approached locally, and successful exploitation needs a single authentication. With known technical details, no exploit is available\cite{vuldb}. A possible race condition occurs between driver\_override\_store() and driver\_override\_show().

The \texttt{driver\_override} patch was a result to allow the driver for a device to be specified which would override standard OF, ACPI, ID table and name matching. When specified, if a driver has a name matching the \texttt{driver\_overrid}e, the driver will have an opportunity to bind to the device which is specified by a writing a string to the \texttt{driver\_override} file. This is done in the \texttt{driver\_override\_store()} function as seen in figure 2.1. To note, any device that represents a platform device(i.e \texttt{struct platform\_device}) allows them to connect to a virtual "platform bus". This allows the kernel to communicate with devices via a specified driver that are not necessarily ``plug and play'' \cite{source-code}.


%The current driver will not automatically unbind from the device from writing to driver\_override nor make any attempt to automatically load the specified driver.  If the new driver doesn't match the name that is currently loaded in the kernel, the device will not bind to any driver.  This also allows devices to opt-out of driver binding using a driver\_override name such as "none".
%
%Platform devices have long been used in this role in the kernel. 
%So now we have a driver for a platform device, but no actual devices yet. As we noted at the beginning, platform devices are inherently not discoverable, so there must be another way to tell the kernel about their existence. That is typically done with the creation of a static \texttt{platform\_device} structure providing, at a minimum, a name which is used to find the associated driver. The platform.c file provides a platform 'pseudo' bus for legacy devices\cite{source-code} (i.e. for devices that are not ``plug and play'').
%
%If an ID table is present, the platform bus code will scan through it every time it has to find a driver for a new platform device. If the device's name matches the name in an ID table entry, the device will be given to the driver for management; a pointer to the matching ID table entry will be made available to the driver as well. Platform drivers make them selves known to the kernel with \texttt{int platform\_driver\_register(struct platform\_driver *driver)}


\subsection{Exact Location and Execution of Problem}
The problem occurs due to shared memory between two threads, one which can be calling a store() and the other a show(). In Figure 2.1 the race condition occurs from calling \texttt{pdev->driver\_override} on lines 19 to 24. Show() requires access to the same data at lines 4 - 6 in Figure 2.2. If \texttt{sprintf()} does not finish writing to \texttt{buf} before the memory storing \texttt{pdev->driver\_override} is freed, this will cause corruption.

Suppose there are two threads $T_1$, and $T_2$ are performing a store(), show() operation, respectively. Thread $T_1$ reads \texttt{old=pdev->driver\_override}. Then $T_2$ calls \texttt{sprintf(buf, "\%s\textbackslash n", pdev->driver\_override)}. When \texttt{sprintf()} starts reading from \texttt{pdev->driver\_override}, Thread $T_1$ executes \texttt{pdev->driver\_override = driver\_override} followed by kfree(old) corrupting thread $T_2$'s execution. 

Similarly, there could be a data race between multiple threads performing a store() where memory leaks are possible\cite{lorekernel}. 
\newpage
\begin{lstlisting}[style=CStyle]
static ssize_t driver_override_store(struct device *dev,
				     struct device_attribute *attr,
				     const char *buf, size_t count)
{
	struct platform_device *pdev = to_platform_device(dev);
	char *driver_override, *old = pdev->driver_override, *cp;

	if (count > PATH_MAX)
		return -EINVAL;

	driver_override = kstrndup(buf, count, GFP_KERNEL);
	if (!driver_override)
		return -ENOMEM;

	cp = strchr(driver_override, '\n');
	if (cp)
		*cp = '\0';

	if (strlen(driver_override)) {
		pdev->driver_override = driver_override;
	} else {
		kfree(driver_override);
		pdev->driver_override = NULL;
	}

	kfree(old);

	return count;
}
\end{lstlisting}
\centerline{\textbf{Figure 2.1: \texttt{driver\_override\_store()}}}
\vspace{12pt}

\begin{lstlisting}[style=CStyle]
static ssize_t driver_override_show(struct device *dev,
				    struct device_attribute *attr, char *buf)
{
	struct platform_device *pdev = to_platform_device(dev);

	return sprintf(buf, "%s\n", pdev->driver_override);
}
\end{lstlisting}
\centerline{\textbf{Figure 2.2: \texttt{driver\_override\_show()}}}
\vspace{12pt}

\subsection{Solution}
The solution requires adding a lock to avoid race condition. The lock tries to protect against a race between store and show. In Figure 2.3, the first change is made to set \texttt{old=pdev->driver\_override} before modifying \texttt{pdev->driver\_override}. To provide atomicity, the device , \texttt{dev}, from which \texttt{pdev} was called is locked. Therefore, this will provide a means of mutual exclusion. The threads then finish and unlock as seen in lines 5 and 13.

%\begin{lstlisting}[style=CStyle]
%
%static ssize_t driver_override_store(struct device *dev,
% 				     const char *buf, size_t count)
% {
% 	struct platform_device *pdev = to_platform_device(dev);
%-	char *driver_override, *old = pdev->driver_override, *cp;
%+	char *driver_override, *old, *cp;
% 
% 	if (count > PATH_MAX)
% 		return -EINVAL;
%\end{lstlisting}

\newpage
\begin{lstlisting}[style=CStyle]
static ssize_t driver_override_store(struct device *dev,
 	if (cp)
 		*cp = '\0';
 
+	device_lock(dev);
+	old = pdev->driver_override;
 	if (strlen(driver_override)) {
 		pdev->driver_override = driver_override;
 	} else {
 		kfree(driver_override);
 		pdev->driver_override = NULL;
 	}
+	device_unlock(dev);
 
 	kfree(old);
\end{lstlisting}
\centerline{\textbf{Figure 2.3: Solution to \texttt{driver\_override\_store()}}}
\vspace{12pt}

To safeguard show(), the same method is taken and a lock is used as seen in Figure 2.4. the lock prevents an interrupt during the execution of \texttt{sprintf()}. Therefore, only one thread may be able to read and write to the device's driver\_override.
\begin{lstlisting}[style=CStyle]
static ssize_t driver_override_show(struct device *dev,
 				    struct device_attribute *attr, char *buf)
{
 	struct platform_device *pdev = to_platform_device(dev);
+	ssize_t len;
 
-	return sprintf(buf, "%s\n", pdev->driver_override);
+	device_lock(dev);
+	len = sprintf(buf, "%s\n", pdev->driver_override);
+	device_unlock(dev);
+	return len;
}
\end{lstlisting}
\centerline{\textbf{Figure 2.4: Solution to \texttt{driver\_override\_show()}}}
\vspace{12pt}

\subsection{Concurrency and Synchronization}
Due to the lock used on the device, this creates a bottleneck of contention for the lock if many threads are competing for it. These two function now have a sequential behavior and are no longer concurrent, which is most likely a good thing. However, the behavior is now linearizable and overlapping events are sequentially consistent and well defined. Because of the lock, there is no possibility of the memory pointed to \texttt{pdev->driver\_override} changing while show() is writing to a buffer. Using the lock ensures that if the thread reading the \texttt{driver\_override} starts then it will atomically write whatever it expects. 

\newpage
\begin{thebibliography}{9}
\bibitem{NVD}
	\textit{CVE-2017-15102 Detail}. Edited by NVD, 15 Nov. 2017, nvd.nist.gov/vuln/detail/CVE-2017-15102.
	
\bibitem{Code}
	\textit{Torvalds, L. Torvalds/Linux}. \\github.com/torvalds/linux/blob/master/drivers/usb/misc/legousbtower.c.
	
\bibitem{Fix}
	\textit{Torvalds, L. (n.d.). Torvalds/linux}. Retrieved form \\
	https://github.com/torvalds/linux/commit/2fae9e5a7babada041e2e161699ade2447a01989

\bibitem{bugzilla}
Bugzilla.\textit{ CVE-2017-12146 Kernel: Race Condition in driver\_override Implementation}. 25 Sept. 2017, bugzilla.redhat.com/show\_bug.cgi?id=CVE-2017-12146

\bibitem{ubuntu-security} 
Canonical Ltd. Ubuntu CVE Tracker. people.canonical.com/~ubuntu-security/cve/2017/CVE-2017-12146.html.

\bibitem{vuldb}
\textit{Linux Kernel up to 4.12.0 Drivers/Base/Platform.c driver\_override Privilege Escalationedit.} vuldb.com/?id.106296.

\bibitem{source-code}
Bootlin. elixir.bootlin.com/linux/v4.12.14/source/drivers/base/platform.c.


\bibitem{lorekernel}
“Driver Core: Platform: Fix Race Condition with driver\_override 783378 Diff Mbox Series.” Driver Core: Platform: Fix Race Condition with driver\_override - Patchwork, lore.kernel.org/patchwork/patch/783378/.

\bibitem{drivover}
\textit{[Libvirt] [PATCH] Driver Core: Platform: Add Device Binding Path 'driver\_override'.} www.redhat.com/archives/libvir-list/2014-April/msg00382.html.
\end{thebibliography}

\end{document}

